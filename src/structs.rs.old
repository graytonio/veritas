use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::{Arc, Mutex, RwLock};

trait Configurable {
    fn set_key_value(&mut self, key: &str, value: Value);
    fn get_key_value(&self, key: &str) -> Option<Value>;
    fn remove_key(&mut self, key: &str) -> Option<Value>;
}

#[derive(Debug)]
struct NodeConfig {
    node_id: String,
    key_values: HashMap<String, Value>,
    groups: Vec<String>,
}

#[derive(Debug, Clone)]
enum Value {
    String(String),
    Number(f64),
}

impl Configurable for NodeConfig {
    fn set_key_value(&mut self, key: &str, value: Value) {
        self.key_values.insert(key.to_owned(), value);
    }

    fn get_key_value(&self, key: &str) -> Option<Value> {
        self.key_values.get(key).cloned().or_else(|| {
            let local_group_list = &*GROUPS.read().unwrap();
            for group_id in &self.groups {
                if let Some(group) = local_group_list.get(group_id) {
                    if let Some(value) = group.get_key_value(key) {
                        return Some(value.clone());
                    }
                }
            }
            None
        })
    }

    fn remove_key(&mut self, key: &str) -> Option<Value> {
        self.key_values.remove(key)
    }

}

impl NodeConfig {
    fn new(node_id: String) -> Self {
        NodeConfig {
            node_id: node_id,
            key_values: HashMap::new(),
            groups: Vec::new(),
        }
    }
}

#[derive(Debug)]
struct GroupConfig {
    group_id: String,
    key_values: HashMap<String, Value>,
}

impl Configurable for GroupConfig {
    fn set_key_value(&mut self, key: &str, value: Value) {
        self.key_values.insert(key.to_owned(), value);
    }

    fn get_key_value(&self, key: &str) -> Option<Value> {
        self.key_values.get(key).cloned()
    }

    fn remove_key(&mut self, key: &str) -> Option<Value> {
        self.key_values.remove(key)
    }
}

impl GroupConfig {
    fn new(group_id: String) -> Self {
        GroupConfig {
            group_id: group_id,
            key_values: HashMap::new(),
        }
    }
}

fn get_node(node_id: &String) -> Option<&NodeConfig> {
    NODES.read().unwrap().get(node_id)
}

fn get_mut_node(node_id: &mut String) -> Option<&mut NodeConfig> {
    NODES.read().unwrap().get_mut(node_id)
}

lazy_static! {
    static ref GROUPS: RwLock<HashMap<String, GroupConfig>> = RwLock::new(HashMap::new());
    static ref NODES: RwLock<HashMap<String, NodeConfig>> = RwLock::new(HashMap::new());
}

fn main() {
    let init_groups = &mut*GROUPS.write().unwrap();

    init_groups.insert("prod-use1".to_string(), GroupConfig::new("prod-use1".to_string()));
    init_groups.insert("prod-usw2".to_string(), GroupConfig::new("prod-usw2".to_string()));

    let init_nodes = &mut*NODES.write().unwrap();

    init_nodes.insert("test-server-0".to_string(), NodeConfig::new("test-server-0".to_string()));
    init_nodes.insert("test-server-1".to_string(), NodeConfig::new("test-server-1".to_string()));
}
